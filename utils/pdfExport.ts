
import { jsPDF } from "jspdf";
import { Book, ExportSettings, TrimSize } from "../types";

const PAGE_SIZES: Record<TrimSize, { width: number; height: number }> = {
  '5x8': { width: 5, height: 8 },
  '6x9': { width: 6, height: 9 },
  '7x10': { width: 7, height: 10 }
};

export const downloadPdf = (book: Book, settings: ExportSettings) => {
  const baseSize = PAGE_SIZES[settings.trimSize];
  
  // Calculate final dimensions with bleed if enabled
  // Standard bleed is 0.125" on outside edges. For simplicity here, we add to W/H.
  // Real KDP: Width + 0.125 (outer), Height + 0.25 (top/bottom)
  const bleedW = settings.includeBleed ? 0.125 : 0;
  const bleedH = settings.includeBleed ? 0.25 : 0;
  
  const finalWidth = baseSize.width + bleedW;
  const finalHeight = baseSize.height + bleedH;

  const doc = new jsPDF({
    orientation: "portrait",
    unit: "in",
    format: [finalWidth, finalHeight]
  });

  const margin = 0.75 + (settings.includeBleed ? 0.125 : 0);
  const contentWidth = finalWidth - (margin * 2);
  const contentBottom = finalHeight - margin;
  let y = margin;
  const lineHeight = 0.22;

  // --- Front Cover ---
  if (book.frontCover?.imageUrl) {
      try {
        // Cover always fills the page (full bleed equivalent)
        doc.addImage(book.frontCover.imageUrl, "PNG", 0, 0, finalWidth, finalHeight);
        
        // Overlay Title if strictly needed (simple fallback for visibility)
        doc.setFillColor(0, 0, 0); 
        // Semi-transparent hack not available, just small box at top
        doc.rect(0, finalHeight * 0.05, finalWidth, finalHeight * 0.15, "F");
        
        doc.setFont("times", "bold");
        doc.setFontSize(settings.trimSize === '5x8' ? 24 : 32);
        doc.setTextColor(255, 255, 255);
        
        const titleText = book.frontCover.titleText || book.title;
        const titleLines = doc.splitTextToSize(titleText.toUpperCase(), finalWidth - 1);
        doc.text(titleLines, finalWidth / 2, finalHeight * 0.1 + 0.1, { align: "center" });

        doc.setFontSize(settings.trimSize === '5x8' ? 12 : 14);
        doc.setFont("sans", "normal");
        const subText = book.frontCover.subtitleText || book.subtitle;
        doc.text(subText, finalWidth / 2, finalHeight * 0.1 + (titleLines.length * 0.4), { align: "center" });

      } catch (e) {
        console.warn("Front cover render failed", e);
      }
      doc.addPage();
  } else {
      // Text Fallback
      doc.setFont("times", "bold");
      doc.setFontSize(24);
      doc.setTextColor(0);
      const titleLines = doc.splitTextToSize(book.title.toUpperCase(), contentWidth);
      const titleHeight = doc.getTextDimensions(titleLines).h;
      doc.text(titleLines, margin, finalHeight / 3, { align: "center" });

      doc.setFont("times", "normal");
      doc.setFontSize(14);
      const subLines = doc.splitTextToSize(book.subtitle, contentWidth);
      doc.text(subLines, margin, finalHeight / 3 + titleHeight + 0.5, { align: "center" });
      
      doc.setFontSize(9);
      doc.setTextColor(100);
      doc.text("Generated by Y-It Engine v3.0", margin, finalHeight - margin, { align: "center" });
      doc.addPage();
  }

  // --- TOC ---
  doc.setFont("times", "bold");
  doc.setFontSize(16);
  doc.setTextColor(0);
  doc.text("TABLE OF CONTENTS", margin, margin + 0.5);
  
  let tocY = margin + 1.2;
  doc.setFont("times", "normal");
  doc.setFontSize(11);

  book.chapters.forEach((chapter) => {
    doc.text(`Chapter ${chapter.number}: ${chapter.title}`, margin, tocY);
    tocY += 0.3;
  });

  // --- Content ---
  let currentPdfPage = 3; 

  const addNewPage = () => {
    doc.addPage();
    currentPdfPage++;
    y = margin;
  };

  const checkSpace = (heightNeeded: number) => {
    if (y + heightNeeded > contentBottom) {
      addNewPage();
    }
  };

  book.chapters.forEach((chapter) => {
    doc.addPage();
    currentPdfPage++;
    y = margin + 0.5;

    // Chapter Title
    doc.setFont("times", "bold");
    doc.setFontSize(10);
    doc.setTextColor(100);
    doc.text(`CHAPTER ${chapter.number}`, margin, y);
    y += 0.25;
    
    doc.setFontSize(18);
    doc.setTextColor(0);
    const chTitleLines = doc.splitTextToSize(chapter.title.toUpperCase(), contentWidth);
    doc.text(chTitleLines, margin, y);
    y += (chTitleLines.length * 0.3) + 0.5;

    // Hero Image
    const hero = chapter.visuals?.find(v => v.type === 'HERO' && v.imageUrl);
    if (hero && hero.imageUrl) {
        try {
            const imgHeight = finalHeight * 0.35; 
            checkSpace(imgHeight + 0.5);
            doc.addImage(hero.imageUrl, "PNG", margin, y, contentWidth, imgHeight);
            y += imgHeight + 0.4;
        } catch (e) {
             console.warn("Image error", e);
        }
    }

    // Body Text
    doc.setFont("times", "normal");
    doc.setFontSize(11);
    
    const paragraphs = chapter.content.split('\n');
    
    paragraphs.forEach(para => {
        let text = para.trim();
        if (!text) {
             y += lineHeight; 
             return; 
        }

        let isBold = false;
        let fontSize = 11;
        
        if (text.startsWith('#')) {
             isBold = true;
             text = text.replace(/^#+\s*/, '');
             fontSize = 12;
        } 
        if (text.match(/^\*\*.*\*\*$/)) {
             isBold = true;
             text = text.replace(/\*\*/g, '');
        }

        doc.setFont("times", isBold ? "bold" : "normal");
        doc.setFontSize(fontSize);

        const cleanText = text.replace(/[*_`]/g, '');
        const lines = doc.splitTextToSize(cleanText, contentWidth);
        checkSpace(lines.length * lineHeight);
        
        doc.text(lines, margin, y);
        y += (lines.length * lineHeight) + 0.08;
    });

    // Other Visuals
    if (chapter.visuals) {
        chapter.visuals.forEach(vis => {
             if (vis.type !== 'HERO' && vis.imageUrl) {
                 const imgHeight = finalHeight * 0.3;
                 checkSpace(imgHeight + 0.4);
                 y += 0.2;
                 try {
                     doc.addImage(vis.imageUrl, "PNG", margin, y, contentWidth, imgHeight);
                     y += imgHeight + 0.2;
                     
                     if (vis.caption) {
                         doc.setFont("times", "italic");
                         doc.setFontSize(9);
                         const capLines = doc.splitTextToSize(vis.caption, contentWidth);
                         checkSpace(capLines.length * 0.15);
                         doc.text(capLines, margin, y, { align: "center", maxWidth: contentWidth });
                         y += (capLines.length * 0.15) + 0.2;
                     }
                 } catch(e) {
                     console.warn("Visual error", e);
                 }
             }
        });
    }
  });

  // --- Back Cover ---
  if (book.backCover?.imageUrl) {
      doc.addPage();
      try {
          doc.addImage(book.backCover.imageUrl, "PNG", 0, 0, finalWidth, finalHeight);
      } catch (e) {
          console.warn("Back cover render error", e);
      }
  }

  // --- Pagination ---
  const totalPages = doc.getNumberOfPages();
  let contentPageNum = 1;

  for (let i = 1; i <= totalPages; i++) {
       const isLastPage = (i === totalPages && !!book.backCover?.imageUrl);
       // Skip covers and TOC in pagination
       if (i > 2 && !isLastPage) {
           doc.setPage(i);
           doc.setFont("times", "normal");
           doc.setFontSize(9);
           doc.setTextColor(50);
           doc.text(`${contentPageNum}`, finalWidth / 2, finalHeight - 0.5, { align: "center" });
           contentPageNum++;
       }
  }

  const safeFilename = book.title.replace(/[^a-z0-9]/gi, '_').toLowerCase().substring(0, 50);
  doc.save(`${safeFilename}_y-it_${settings.trimSize}.pdf`);
};
